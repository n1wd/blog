版本控制策略    
==========

参考资料：[项目svn版本控制中的分支策略][1]

Basically stable
----------------

### 定义:

>顾名思义这个分支原则主导思想是trunk只包含稳定的随时可发布的代码。branches则用于开发新功能/修正bug/发布前的QA控制/重构/实验性质功能试点。

>该原则下最严格的遵行方式为：任何未经严格QA控制的代码都不能merge回trunk。这样便能保证任何时刻都可以从trunk上分出一个release candidate(rc)，它只需要通过少量的QA控制流程便能进入正式发布。
>不那么严格的遵行方式则允许通过开发者的unit-testing的代码merge回trunk。这种稍微宽松的方式则需要通过全套的QA控制监督才能进入正式发布流程。

### 优点：

* 任何时刻可以分出一个release。并配以简单QA控制就加以发布。
* 因为trunk只包含稳定的代码，并且变动的节奏很慢；所以你可以在branch上作大量的实验性改动，而不用担心merge回trunk时会和别人的工作掺杂在一起而导致bug。
    
### 缺点：

* merge通常由QA测试员来进行而不是理解代码语义的编写者来进行。
* 在从一个branch往trunk merge完成后，trunk上的改动相对于这个branch被分出去的那个版本来说，可能是巨大的。当然这两个问题都可以通过使开发者周期性地merge回trunk而得到一定程度上的减轻；或者遵行更为宽松的merge要求。

### crystal项目应用：

1. trunk是个稳定的版本，里面始终保持当前最新的发布版。
2. 当有新的需求来的时候，在trunk上开出一个branch。
3. bugfix也在当前branch。
4. 当branch完成开发测试时候，merge回trunk，再打个发布的tag。

#####       噪点：
1.      当有多个需求需要开出几个branch时候，merge的时候容易产生冲突。
2.      在merge回trunk后理论上还需要回归测试。

#####       解决方案：
1.      手工merge或者用git
2.      看测试那边流程或者说资源能否支持到？



Basically unstable
------------------

### 定义

>要求trunk包含最新的代码，不管它的稳定性如何；而用于release candidate的版本则应该开辟一个分支来交付。

>该原则下最严格的遵行方式为：所有开发都在trunk上进行，只有rc,bugfix branch，release等性质的事件才会开辟branch。
>稍为宽松的遵行方式为则允许使用branch来进行实验性编码，重构，以及其他特殊用途的代码开发。而往trunk merge则通常由相应branch的负责者来完成。
  
### 优点:

* merge是个不常发生的事情，而且是个相对容易完成的事情———因为是由熟悉branch代码的负责者来完成merge。

### 缺点:

* 显然是trunk包含了不稳定的代码，可能是实验性功能，甚至连编译都不能通过的代码。经常进行tagging可以减少这个缺点带来的影响，所以每次对每次实验功能和重构等进行tag操作是个好习惯。更宽松的的遵行方式是将那些bug倾向极大的代码从trunk上branch出去，为随时从trunk准备一个release提供更好的环境。

### crystal项目应用：

1. 所有的开发都在trunk上，在提交代码的时候注意先更新其他人的提交再提交自己的代码。
2. 当当前版本开发完成后，生成一个branch作为新版本的发布，打tag提测。
3. bugfix都在生成的branch里面。
4. 当branch完成开发测试时候，再打个发布的tag。
5. 把发布的branch merge回trunk中。

#####       噪点：
1.      不能做到每个人/需求一个branch，可能需要n个feature一个发布版本。
2.      trunk包含了不稳定的代码，可能是实验性功能，甚至连编译都不能通过的代码。

#####       解决方案：
1.      项目统一规划，指定固定发布周期。
2.      要求每个人提交到trunk的代码必须是可运行的，这是一个良好的工程习惯。

参考资料：[项目svn版本控制中的分支策略][1]

[1]: http://blog.csdn.net/akara/article/details/5662624 "项目svn版本控制中的分支策略"
